options 
{
	STATIC = false;
}

PARSER_BEGIN(CParser)

package fr.univ_nantes.alma.archtool.parsing;

import java.util.*;

public class CParser
{
	
    public static void main (String args [])
    {
		CParser parser ;

		if(args.length == 0)
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Reading from standard input . . .");
        	parser = new CParser(System.in);
      	}
      	else if(args.length == 1)
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Reading from file " + args[0] + " . . ." );
      		try 
      		{
        		parser = new CParser(new java.io.FileInputStream(args[0]));
      		}
      		catch(java.io.FileNotFoundException e)
      		{
        		System.out.println("C Parser Version 0.1:  File " + args[0] + " not found.");
        		return ;
        	}
      	}
      	else 
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Usage is one of:");
        	System.out.println("         java CParser < inputfile");
        	System.out.println("OR");
        	System.out.println("         java CParser inputfile");
        	return;
      	}
      
      	try 
      	{
        	parser.translationUnit();
        	System.out.println("C Parser Version 0.1Alpha:  Java program parsed successfully.");
      	}
      	catch(ParseException e)
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Encountered errors during parse.");
        	e.printStackTrace();
      	}
	}
}

PARSER_END(CParser)

TOKEN: /* Keywords */
{
      <AUTO: "auto">
	| <BREAK:  "break">
	| <CASE: "case">
	| <CHAR: "char">
	| <CONST: "const">
	| <CONTINUE: "continue">
	| <DFLT: "default">
	| <DO: "do">
	| <DOUBLE: "double">
	| <ELSE: "else">
	| <ENUM: "enum">
	| <EXTERN: "extern">
	| <FLOAT: "float">
	| <FOR: "for">
	| <GOTO: "goto">
	| <IF: "if">
	| <INLINE: "inline">
	| <INT: "int">
	| <LONG: "long">
	| <REGISTER: "register">
	| <RESTRICT: "restrict">
	| <RETURN: "return">
	| <SHORT: "short">
	| <SIGNED: "signed">
	| <SIZEOF: "sizeof">
	| <STATIC: "static">
	| <STRUCT: "struct">
	| <SWITCH: "switch">
	| <TYPEDEF: "typedef">
	| <UNION: "union">
	| <UNSIGNED: "unsigned">
	| <VOID: "void">
	| <VOLATILE: "volatile">
	| <WHILE: "while">
	| <ALIGNAS: "_Alignas">
	| <ALIGNOF: "_Alignof">
	| <ATOMIC: "_Atomic">
	| <BOOL: "_Bool">
	| <COMPLEX: "_Complex">
	| <GENERIC: "_Generic">
	| <IMAGINARY: "_Imaginary">
	| <NORETURN: "_Noreturn">
	| <STATIC_ASSERT: "_Static_assert">
	| <THREAD_LOCAL: "_Thread_local">
}

TOKEN:
{
      <NON_DIGIT: ["_","a"-"z", "A"-"Z"]>
	| <DIGIT: ["0"-"9"]>
	| <HEXADECIMAL_DIGIT: ["0"-"9", "a"-"z", "A"-"Z"]>
	| <HEXADECIMAL_PREFIX: "0x" | "0X">
	| <NON_ZERO_DIGIT: ["1"-"9"]>
	| <OCTAL_DIGIT: ["0"-"7"]>
	| <UNSIGNED_SUFFIX: ["u", "U"] >
	| <LONG_SUFFIX: ["l", "L"]>
	| <LONG_LONG_SUFFIX: "ll" | "LL">
	| <FLOATING_SUFFIX: ["f", "l", "F", "L"]>
	| <SIGN: ["+", "-"]>
	| <SIMPLE_ESCAPE_SEQUENCE: "">
	| <ENCODING_PREFIX: "u8" | "u" | "U" | "L">
	| <CHARACTER_LITERAL: (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))>
}

/************************************ Identifiers ************************************/

void identifier() : {}
{            
	identifierNonDigit() ( identifierNonDigit() | <DIGIT> )*
}

void identifierNonDigit() : {}
{            
	<NON_DIGIT> | 
	universalCharacterName()
}

void universalCharacterName() : {}
{            
	"\\u" hexQuad() | 
	"\\U" hexQuad() hexQuad()
}

void hexQuad() : {}
{            
	<HEXADECIMAL_DIGIT> <HEXADECIMAL_DIGIT> <HEXADECIMAL_DIGIT> <HEXADECIMAL_DIGIT>
}

void constant() : {}
{            
	integerConstant() |
	floatingConstant() |
	enumerationConstant() |
	characterConstant()
}

void integerConstant() : {}
{            
	decimalConstant() [ integerSuffix() ] |
	octalConstant() [ integerSuffix() ] |
	hexadecimalConstant() [ integerSuffix() ]
}

void decimalConstant() : {}
{            
	<NON_ZERO_DIGIT> ( <DIGIT> )*
}

void octalConstant() : {}
{            
	"0" ( <OCTAL_DIGIT> )*
}

void hexadecimalConstant() : {}
{            
	<HEXADECIMAL_PREFIX> ( <HEXADECIMAL_DIGIT> )+
}

void integerSuffix() : {}
{            
	<UNSIGNED_SUFFIX> [ <LONG_SUFFIX> ] |
	<UNSIGNED_SUFFIX> <LONG_LONG_SUFFIX> |
	<LONG_SUFFIX> [ <UNSIGNED_SUFFIX> ] |
	<LONG_LONG_SUFFIX> [ <UNSIGNED_SUFFIX> ]
}

void floatingConstant() : {}
{            
	decimalFloatingConstant() |
	hexadecimalFloatingConstant()
}

void decimalFloatingConstant() : {}
{            
	fractionalConstant() [ exponentPart() ] [ <FLOATING_SUFFIX> ] |
	digitSequence() exponentPart() [ <FLOATING_SUFFIX> ]
}

void hexadecimalFloatingConstant() : {}
{            
	<HEXADECIMAL_PREFIX> hexadecimalFractionalConstant()
		binaryExponentPart() [ <FLOATING_SUFFIX> ] |
	<HEXADECIMAL_PREFIX> hexadecimalDigitSequence()
		binaryExponentPart() [ <FLOATING_SUFFIX> ]
}

void fractionalConstant() : {}
{            
	[ digitSequence() ] "." digitSequence() |
	digitSequence() "."
}

void exponentPart() : {}
{            
	"e" [ <SIGN> ] digitSequence() |
	"E" [ <SIGN> ] digitSequence()
}

void digitSequence() : {}
{            
	( <DIGIT> )+
}

void hexadecimalFractionalConstant() : {}
{            
	[ hexadecimalDigitSequence() ] "." hexadecimalDigitSequence() |
	hexadecimalDigitSequence() "."
}

void binaryExponentPart() : {}
{            
	"P" [ <SIGN> ] digitSequence() |
	"p" [ <SIGN> ] digitSequence()
}

void hexadecimalDigitSequence() : {}
{            
	( <HEXADECIMAL_DIGIT> )+
}

void enumerationConstant() : {}
{            
	identifier()
}

void characterConstant() : {}
{            
	"'" cCharSequence() "'" |
	"L'" cCharSequence() "'" |
	"u'" cCharSequence() "'" |
	"U'" cCharSequence() "'"
}

void cCharSequence() : {}
{            
	( cChar() )+
}

void cChar() : {}
{            
	<CHARACTER_LITERAL> |
	escapeSequence()
}

void escapeSequence() : {}
{            
	<SIMPLE_ESCAPE_SEQUENCE> |
	octalEscapeSequence() |
	hexadecimalEscapeSequence() |
	universalCharacterName()
}

void octalEscapeSequence() : {}
{            
	"\\" <OCTAL_DIGIT> |
	"\\" <OCTAL_DIGIT> <OCTAL_DIGIT> |
	"\\" <OCTAL_DIGIT> <OCTAL_DIGIT> <OCTAL_DIGIT>
}

void hexadecimalEscapeSequence() : {}
{            
	"\\x" ( <HEXADECIMAL_DIGIT> )+
}

void stringLiteral() : {}
{            
	[ <ENCODING_PREFIX> ] "\"" [ sCharSequence() ] "\""
}

void sCharSequence() : {}
{            
	( sChar() )+
}

void sChar() : {}
{            
	<CHARACTER_LITERAL> |
	escapeSequence()
}

/************************************ Expressions ************************************/

void pimaryExpression() : {}
{            
	identifier() | 
	constant() | 
	stringLiteral() | 
	"(" expression() ")" | 
	genericSelection() 
}

void genericSelection() : {}
{
	<GENERIC> "(" assignmentExpression() "," genericAssocList() ")"
}

void genericAssocList() : {}
{
	genericAssociation() ( "," genericAssociation() )*
}

void genericAssociation() : {}
{
	typeName() ":" assignmentExpression() | 
	<DFLT> ":" assignmentExpression()
}

void postfixExpression() : {}
{
	( pimaryExpression() |
	"(" typeName() ")" "{" initializerList() "}" |
	"(" typeName() ")" "{" initializerList() "," "}" ) ( "[" expression() "]" |
		"(" [ argumentExpressionList() ] ")" |
		"." identifier() |
		"->" identifier() |
		"++" |
		"--" )*
}

void argumentExpressionList() : {}
{
	assignmentExpression() ( "," assignmentExpression() )*
}

void unaryExpression() : {}
{
	postfixExpression() |
	"++" unaryExpression() |
	"--" unaryExpression() |
	unaryOperator() castExpression() |
	<SIZEOF> unaryExpression() |
	<SIZEOF> "(" typeName() ")" |
	<ALIGNOF> "(" typeName() ")"
}

void unaryOperator() : {}
{
	"&" |
	"*" |
	"+" |
	"-" |
	"~" |
	"!"
}

void castExpression() : {}
{
	unaryExpression() |
	"(" typeName() ")" castExpression()
}

void multiplicativeExpression() : {}
{
	castExpression() ( ( "*" | "/" | "%" ) castExpression() )*
}

void additiveExpression() : {}
{
	multiplicativeExpression() ( ( "+" | "-" ) multiplicativeExpression() )*
}

void shiftExpression() : {}
{
	additiveExpression() ( ( "<<" | ">>" ) additiveExpression() )*
}

void relationalExpression() : {}
{
	shiftExpression() ( ( "<" | ">" | "<=" | ">=" ) shiftExpression() )*
}

void equalityExpression() : {}
{
	relationalExpression() ( ( "==" | "!=" ) relationalExpression() )*
}

void andExpression() : {}
{
	equalityExpression() ( "&" equalityExpression() )*
}

void exclusiveOrExpression() : {}
{
	andExpression() ( "^" andExpression() )*
}

void inclusiveOrExpression() : {}
{
	exclusiveOrExpression() ( "|" exclusiveOrExpression() )*
}

void logicalAndExpression() : {}
{
	inclusiveOrExpression() ( "&&" inclusiveOrExpression() )*
}

void logicalOrExpression() : {}
{
	logicalAndExpression() ( "||" logicalAndExpression() )*
}

void conditionalExpression() : {}
{
	logicalOrExpression() |
	logicalOrExpression() "?" expression()  ":" conditionalExpression()
}

void assignmentExpression() : {}
{
	conditionalExpression() |
	unaryExpression() assignmentOperator() assignmentExpression()
}

void assignmentOperator() : {}
{
	"=" |
	"*=" |
	"/=" |
	"%=" |
	"+=" |
	"-=" |
	"<<=" |
	">>=" |
	"&=" |
	"^=" |
	"|="
}

void expression() : {}
{
	assignmentExpression() ( "," assignmentExpression() )*
}

void constantExpression() : {}
{
	conditionalExpression()
}

/************************************ Declarations ************************************/

void declaration() : {}
{
	declarationSpecifiers() [ initDeclaratorList() ] ";" |
	staticAssertDeclaration()
}

void declarationSpecifiers() : {}
{
	storageClassSpecifier() [ declarationSpecifiers() ] |
	typeSpecifier() [ declarationSpecifiers() ] |
	typeQualifier() [ declarationSpecifiers() ] |
	functionSpecifier() [ declarationSpecifiers() ] |
	alignmentSpecifier() [ declarationSpecifiers() ]
}

void initDeclaratorList() : {}
{
	initDeclarator() ( "," initDeclarator() )*
}

void initDeclarator() : {}
{
	declarator() |
	declarator() "=" initializer()
}

void storageClassSpecifier() : {}
{
	<TYPEDEF> |
	<EXTERN> |
	<STATIC> |
	<THREAD_LOCAL> |
	<AUTO> |
	<REGISTER>
}

void typeSpecifier() : {}
{
	<VOID> |
	<CHAR> |
	<SHORT> |
	<INT> |
	<LONG> |
	<FLOAT> |
	<DOUBLE> |
	<SIGNED> |
	<UNSIGNED> |
	<BOOL> |
	<COMPLEX> |
	atomicTypeSpecifier() |
	structOrUnionSpecifier() |
	enumSpecifier() |
	typedefName()
}

void structOrUnionSpecifier() : {}
{
	structOrUnion() [ identifier() ] "{" structDeclarationList() "}" |
	structOrUnion() identifier()
}

void structOrUnion() : {}
{
	<STRUCT>  |
	<UNION>
}

void structDeclarationList() : {}
{
	( structDeclaration() )+
}

void structDeclaration() : {}
{
	specifierQualifierList() [ structDeclaratorList() ] ";" |
	staticAssertDeclaration()
}

void specifierQualifierList() : {}
{
	typeSpecifier() [ specifierQualifierList() ] |
	typeQualifier() [ specifierQualifierList() ]
}

void structDeclaratorList() : {}
{
	structDeclarator() ( "," structDeclarator() )*
}

void structDeclarator() : {}
{
	declarator() |
	[ declarator() ] ":" constantExpression()
}

void enumSpecifier() : {}
{
	<ENUM> [ identifier() ] "{" enumeratorList() "}" |
	<ENUM> [ identifier() ] "{" enumeratorList() "," "}" |
	<ENUM> identifier()
}

void enumeratorList() : {}
{
	enumerator() ( "," enumerator() )*
}

void enumerator() : {}
{
	enumerationConstant() |
	enumerationConstant() "=" constantExpression()
}

void atomicTypeSpecifier() : {}
{
	<ATOMIC> "(" typeName() ")"
}

void typeQualifier() : {}
{
	<CONST> |
	<RESTRICT> |
	<VOLATILE> |
	<ATOMIC>
}

void functionSpecifier() : {}
{
	<INLINE> |
	<NORETURN>
}

void alignmentSpecifier() : {}
{
	<ALIGNAS> "(" typeName() ")" |
	<ALIGNAS> "(" constantExpression() ")"
}

void declarator() : {}
{
	[ pointer() ] directDeclarator()
}

void directDeclarator() : {}
{
	( identifier() | "(" declarator() ")" ) ( "[" [ typeQualifierList() ] [ assignmentExpression() ] "]" |
		 "[" <STATIC> [ typeQualifierList() ] assignmentExpression() "]" |
		 "[" typeQualifierList()  <STATIC> assignmentExpression() "]" |
 		 "[" [ typeQualifierList() ] "*" "]" |
 		 "(" parameterTypeList() ")" |
 		 "(" [ identifierList() ] ")" )*
}

void pointer() : {}
{
	"*" [ typeQualifierList() ] |
	[ typeQualifierList() ] "*" pointer()
}

void typeQualifierList() : {}
{
	( typeQualifier() )+
}

void parameterTypeList() : {}
{
	parameterList() |
	parameterList() "," "..."
}

void parameterList() : {}
{
	parameterDeclaration() ( "," parameterDeclaration() )*
}

void parameterDeclaration() : {}
{
	declarationSpecifiers() declarator() |
	declarationSpecifiers() [ abstractDeclarator() ]
}

void identifierList() : {}
{
	identifier() ( "," identifier() )*
}

void typeName() : {}
{
	specifierQualifierList() [ abstractDeclarator() ]
}

void abstractDeclarator() : {}
{
	pointer() |
	[ pointer() ] directAbstractDeclarator()
}

void directAbstractDeclarator() : {}
{
	"(" abstractDeclarator() ")" ( "[" [ typeQualifierList() ] [ assignmentExpression() ] "]" |
		"[" <STATIC> [ typeQualifierList() ] assignmentExpression() "]" |
		"[" typeQualifierList() <STATIC> assignmentExpression() "]" |
		"[" "*" "]" |
		"(" [ parameterTypeList() ] ")" )* |
	( "[" [ typeQualifierList() ] [ assignmentExpression() ] "]" |
		"[" <STATIC> [ typeQualifierList() ] assignmentExpression() "]" |
		"[" typeQualifierList() <STATIC> assignmentExpression() "]" |
		"[" "*" "]" |
		"(" [ parameterTypeList() ] ")" )+
}

void typedefName() : {}
{
	identifier()
}

void initializer() : {}
{
	assignmentExpression() |
	"{" initializerList() "}" |
	"{" initializerList() "," "}"
}

void initializerList() : {}
{
	[ designation() ] initializer() ( "," [ designation() ] initializer() )*
}

void designation() : {}
{
	designatorList() "="
}

void designatorList() : {}
{
	( designator() )+
}

void designator() : {}
{
	"[" constantExpression() "]" |
	"." identifier()
}

void staticAssertDeclaration() : {}
{
	<STATIC_ASSERT> "(" constantExpression() "," stringLiteral() ")" ";"
}

/************************************ Statements ************************************/

void statement() : {}
{
	labeledStatement() |
	compoundStatement() |
	expressionStatement() |
	selectionStatement() |
	iterationStatement() |
	jumpStatement()
}

void labeledStatement() : {}
{
	identifier()":" statement() |
	<CASE> constantExpression() ":" statement() |
	<DFLT> ":" statement()
}

void compoundStatement() : {}
{
	"{" [ blockItemList() ] "}"
}

void blockItemList() : {}
{
	( blockItem() )+
}

void blockItem() : {}
{
	declaration() |
	statement()
}

void expressionStatement() : {}
{
	[ expression() ] ";"
}

void selectionStatement() : {}
{
	<IF> "(" expression() ")" statement() |
	<IF> "(" expression() ")" statement() <ELSE> statement() |
	<SWITCH> "(" expression() ")" statement()
}

void iterationStatement() : {}
{
	<WHILE> "(" expression() ")" statement() |
	<DO> statement() <WHILE> "(" expression() ")" |
	<FOR> "(" [ expression() ] ";" [ expression() ] ";" [ expression() ] ")" statement() |
	<FOR> "(" declaration() [ expression() ] ";" [ expression() ] ")" statement()
}

void jumpStatement() : {}
{
	<GOTO> identifier() ";" |
	<CONTINUE> ";" |
	<BREAK> ";" |
	<RETURN> [ expression() ] ";"
}

/************************************ External definitions ************************************/

void translationUnit() : {}
{
	( externalDeclaration() )+
}

void externalDeclaration() : {}
{
	functionDefinition() |
	declaration()
}

void functionDefinition() : {}
{
	declarationSpecifiers() declarator() [ declarationList() ] compoundStatement()
}

void declarationList() : {}
{
	( declaration() )+
}