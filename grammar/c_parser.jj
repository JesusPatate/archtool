options 
{
	STATIC = false;
}

PARSER_BEGIN(CParser)

package fr.univ_nantes.alma.archtool.parsing;

import java.util.*;

public class CParser
{
	
    public static void main (String args [])
    {
		CParser parser ;

		if(args.length == 0)
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Reading from standard input . . .");
        	parser = new CParser(System.in);
      	}
      	else if(args.length == 1)
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Reading from file " + args[0] + " . . ." );
      		try 
      		{
        		parser = new CParser(new java.io.FileInputStream(args[0]));
      		}
      		catch(java.io.FileNotFoundException e)
      		{
        		System.out.println("C Parser Version 0.1:  File " + args[0] + " not found.");
        		return ;
        	}
      	}
      	else 
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Usage is one of:");
        	System.out.println("         java CParser < inputfile");
        	System.out.println("OR");
        	System.out.println("         java CParser inputfile");
        	return;
      	}
      
      	try 
      	{
        	parser.translationUnit();
        	System.out.println("C Parser Version 0.1Alpha:  Java program parsed successfully.");
      	}
      	catch(ParseException e)
      	{
        	System.out.println("C Parser Version 0.1Alpha:  Encountered errors during parse.");
        	e.printStackTrace();
      	}
	}
}

PARSER_END(CParser)

SKIP : 
{
	 " "
	| "\t"
	| "\n"
	| "\r"
	| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
	| "#" : PREPROCESSOR_OUTPUT
	
}

<PREPROCESSOR_OUTPUT> SKIP:
{
	"\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
	"\\\n"
 | "\\\r\n"
 | < ~[] >
}

TOKEN : 
{
 	<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
	| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
	| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
	| <#OCTAL_LITERAL: "0" (["0"-"7"])*>
	| <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
	| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
	| <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
	| <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}

TOKEN: /* Keywords */
{
      <AUTO: "auto">
	| <BREAK:  "break">
	| <CASE: "case">
	| <CHAR: "char">
	| <CONST: "const">
	| <CONTINUE: "continue">
	| <DFLT: "default">
	| <DO: "do">
	| <DOUBLE: "double">
	| <ELSE: "else">
	| <ENUM: "enum">
	| <EXTERN: "extern">
	| <FLOAT: "float">
	| <FOR: "for">
	| <GOTO: "goto">
	| <IF: "if">
	| <INLINE: "inline">
	| <INT: "int">
	| <LONG: "long">
	| <REGISTER: "register">
	| <RESTRICT: "restrict">
	| <RETURN: "return">
	| <SHORT: "short">
	| <SIGNED: "signed">
	| <SIZEOF: "sizeof">
	| <STATIC: "static">
	| <STRUCT: "struct">
	| <SWITCH: "switch">
	| <TYPEDEF: "typedef">
	| <UNION: "union">
	| <UNSIGNED: "unsigned">
	| <VOID: "void">
	| <VOLATILE: "volatile">
	| <WHILE: "while">
	| <ALIGNAS: "_Alignas">
	| <ALIGNOF: "_Alignof">
	| <ATOMIC: "_Atomic">
	| <BOOL: "_Bool">
	| <COMPLEX: "_Complex">
	| <GENERIC: "_Generic">
	| <IMAGINARY: "_Imaginary">
	| <NORETURN: "_Noreturn">
	| <STATIC_ASSERT: "_Static_assert">
	| <THREAD_LOCAL: "_Thread_local">
}

TOKEN : 
{
	<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
}

/************************************ External definitions ************************************/

void translationUnit() : {}
{
	( externalDeclaration() )+
}

void externalDeclaration() : {}
{
	LOOKAHEAD(functionDefinition()) functionDefinition() |
	declaration()
}

void functionDefinition() : {}
{
	declarationSpecifiers() declarator() [ declarationList() ] compoundStatement()
}

void declarationList() : {}
{
	( declaration() )+
}

/************************************ Statements ************************************/

void statement() : {}
{
	LOOKAHEAD(2) labeledStatement() |
	compoundStatement() |
	expressionStatement() |
	selectionStatement() |
	iterationStatement() |
	jumpStatement()
}

void labeledStatement() : {}
{
	<IDENTIFIER> ":" statement() |
	<CASE> constantExpression() ":" statement() |
	<DFLT> ":" statement()
}

void compoundStatement() : {}
{
	"{" [ blockItemList() ] "}"
}

void blockItemList() : {}
{
	( blockItem() )+
}

void blockItem() : {}
{
	LOOKAHEAD(3) declaration() |
	statement()
}

void expressionStatement() : {}
{
	[ expression() ] ";"
}

void selectionStatement() : {}
{
	LOOKAHEAD(3) <IF> "(" expression() ")" statement() |
	<IF> "(" expression() ")" statement() <ELSE> statement() |
	<SWITCH> "(" expression() ")" statement()
}

void iterationStatement() : {}
{
	<WHILE> "(" expression() ")" statement() |
	<DO> statement() <WHILE> "(" expression() ")" ";" |
	LOOKAHEAD(3) <FOR> "(" [ expression() ] ";" [ expression() ] ";" [ expression() ] ")" statement() |
	<FOR> "(" declaration() [ expression() ] ";" [ expression() ] ")" statement()
}

void jumpStatement() : {}
{
	<GOTO> <IDENTIFIER> ";" |
	<CONTINUE> ";" |
	<BREAK> ";" |
	<RETURN> [ expression() ] ";"
}

/************************************ Declarations ************************************/

void declaration() : {}
{
	declarationSpecifiers() [ initDeclaratorList() ] ";" |
	staticAssertDeclaration()
}

void declarationSpecifiers() : {}
{
	storageClassSpecifier() [ LOOKAHEAD(declarationSpecifiers()) declarationSpecifiers() ] |
	LOOKAHEAD(2) typeSpecifier() [ LOOKAHEAD(declarationSpecifiers()) declarationSpecifiers() ] |
	typeQualifier() [ LOOKAHEAD(declarationSpecifiers()) declarationSpecifiers() ] |
	functionSpecifier() [ LOOKAHEAD(declarationSpecifiers()) declarationSpecifiers() ] |
	alignmentSpecifier() [ LOOKAHEAD(declarationSpecifiers()) declarationSpecifiers() ]
}

void initDeclaratorList() : {}
{
	initDeclarator() ( "," initDeclarator() )*
}

void initDeclarator() : {}
{
	declarator() [ "=" initializer() ]
}

void storageClassSpecifier() : {}
{
	<TYPEDEF> |
	<EXTERN> |
	<STATIC> |
	<THREAD_LOCAL> |
	<AUTO> |
	<REGISTER>
}

void typeSpecifier() : {}
{
	<VOID> |
	<CHAR> |
	<SHORT> |
	<INT> |
	<LONG> |
	<FLOAT> |
	<DOUBLE> |
	<SIGNED> |
	<UNSIGNED> |
	<BOOL> |
	<COMPLEX> |
	atomicTypeSpecifier() |
	structOrUnionSpecifier() |
	enumSpecifier() |
	typedefName()
}

void structOrUnionSpecifier() : {}
{
	LOOKAHEAD(3) structOrUnion() [ <IDENTIFIER> ] "{" structDeclarationList() "}" |
	structOrUnion() <IDENTIFIER>
}

void structOrUnion() : {}
{
	<STRUCT>  |
	<UNION>
}

void structDeclarationList() : {}
{
	( structDeclaration() )+
}

void structDeclaration() : {}
{
	specifierQualifierList() [ structDeclaratorList() ] ";" |
	staticAssertDeclaration()
}

void specifierQualifierList() : {}
{
	LOOKAHEAD(2) typeSpecifier() [ LOOKAHEAD(2) specifierQualifierList() ] |
	typeQualifier() [ LOOKAHEAD(2) specifierQualifierList() ]
}

void structDeclaratorList() : {}
{
	structDeclarator() ( "," structDeclarator() )*
}

void structDeclarator() : {}
{
	LOOKAHEAD(3) declarator() |
	[ declarator() ] ":" constantExpression()
}

void enumSpecifier() : {}
{
	<ENUM> [ LOOKAHEAD(2) <IDENTIFIER> ] [ "{" enumeratorList() [ "," ] "}" ]
}

void enumeratorList() : {}
{
	enumerator() ( LOOKAHEAD(2) "," enumerator() )*
}

void enumerator() : {}
{
	<IDENTIFIER> [ "=" constantExpression() ]
}

void atomicTypeSpecifier() : {}
{
	<ATOMIC> "(" typeName() ")"
}

void typeQualifier() : {}
{
	<CONST> |
	<RESTRICT> |
	<VOLATILE> |
	<ATOMIC>
}

void functionSpecifier() : {}
{
	<INLINE> |
	<NORETURN>
}

void alignmentSpecifier() : {}
{
	LOOKAHEAD(3) <ALIGNAS> "(" typeName() ")" |
	<ALIGNAS> "(" constantExpression() ")"
}

void declarator() : {}
{
	[ pointer() ] directDeclarator()
}

void directDeclarator() : {}
{
	( <IDENTIFIER> | "(" declarator() ")" ) ( LOOKAHEAD(3) "[" [ typeQualifierList() ] [ assignmentExpression() ] "]" |
		 LOOKAHEAD(2) "[" <STATIC> [ typeQualifierList() ] assignmentExpression() "]" |
		 LOOKAHEAD(3) "[" typeQualifierList()  <STATIC> assignmentExpression() "]" |
 		 "[" [ typeQualifierList() ] "*" "]" |
 		 LOOKAHEAD(3) "(" parameterTypeList() ")" |
 		 "(" [ identifierList() ] ")" )*
}

void pointer() : {}
{
	LOOKAHEAD(3) "*" [ typeQualifierList() ] |
	[ typeQualifierList() ] "*" pointer()
}

void typeQualifierList() : {}
{
	( typeQualifier() )+
}

void parameterTypeList() : {}
{
	LOOKAHEAD(3) parameterList() |
	parameterList() "," "..."
}

void parameterList() : {}
{
	parameterDeclaration() ( LOOKAHEAD(2) "," parameterDeclaration() )*
}

void parameterDeclaration() : {}
{
	LOOKAHEAD(3) declarationSpecifiers() declarator() |
	declarationSpecifiers() [ abstractDeclarator() ]
}

void identifierList() : {}
{
	<IDENTIFIER> ( "," <IDENTIFIER> )*
}

void typeName() : {}
{
	specifierQualifierList() [ abstractDeclarator() ]
}

void abstractDeclarator() : {}
{
	LOOKAHEAD(3) pointer() |
	[ pointer() ] directAbstractDeclarator()
}

void directAbstractDeclarator() : {}
{
	LOOKAHEAD(3) "(" abstractDeclarator() ")" ( LOOKAHEAD(3) "[" [ typeQualifierList() ] [ assignmentExpression() ] "]" |
		LOOKAHEAD(2) "[" <STATIC> [ typeQualifierList() ] assignmentExpression() "]" |
		LOOKAHEAD(2) "[" typeQualifierList() <STATIC> assignmentExpression() "]" |
		"[" "*" "]" |
		"(" [ parameterTypeList() ] ")" )* |
	( LOOKAHEAD(2) "[" [ typeQualifierList() ] [ assignmentExpression() ] "]" |
		LOOKAHEAD(2) "[" <STATIC> [ typeQualifierList() ] assignmentExpression() "]" |
		LOOKAHEAD(2) "[" typeQualifierList() <STATIC> assignmentExpression() "]" |
		"[" "*" "]" |
		"(" [ parameterTypeList() ] ")" )+
}

void typedefName() : {}
{
	<IDENTIFIER>
}

void initializer() : {}
{
	assignmentExpression() |
	"{" initializerList() [ "," ] "}"
}

void initializerList() : {}
{
	[ designation() ] initializer() ( LOOKAHEAD(2) "," [ designation() ] initializer() )*
}

void designation() : {}
{
	designatorList() "="
}

void designatorList() : {}
{
	( designator() )+
}

void designator() : {}
{
	"[" constantExpression() "]" |
	"." <IDENTIFIER>
}

void staticAssertDeclaration() : {}
{
	<STATIC_ASSERT> "(" constantExpression() "," <STRING_LITERAL> ")" ";"
}

/************************************ Expressions ************************************/

void pimaryExpression() : {}
{            
	<IDENTIFIER> | 
	constant() | 
	"(" expression() ")" | 
	genericSelection() 
}

void genericSelection() : {}
{
	<GENERIC> "(" assignmentExpression() "," genericAssocList() ")"
}

void genericAssocList() : {}
{
	genericAssociation() ( "," genericAssociation() )*
}

void genericAssociation() : {}
{
	typeName() ":" assignmentExpression() | 
	<DFLT> ":" assignmentExpression()
}

void postfixExpression() : {}
{
	( LOOKAHEAD(3) pimaryExpression() |
	LOOKAHEAD(3) "(" typeName() ")" "{" initializerList() "}" |
	"(" typeName() ")" "{" initializerList() "," "}" ) ( "[" expression() "]" |
		"(" [ argumentExpressionList() ] ")" |
		"." <IDENTIFIER> |
		"->" <IDENTIFIER> |
		"++" |
		"--" )*
}

void argumentExpressionList() : {}
{
	assignmentExpression() ( "," assignmentExpression() )*
}

void unaryExpression() : {}
{
	postfixExpression() |
	"++" unaryExpression() |
	"--" unaryExpression() |
	unaryOperator() castExpression() |
	LOOKAHEAD(3) <SIZEOF> unaryExpression() |
	<SIZEOF> "(" typeName() ")" |
	<ALIGNOF> "(" typeName() ")"
}

void unaryOperator() : {}
{
	"&" |
	"*" |
	"+" |
	"-" |
	"~" |
	"!"
}

void castExpression() : {}
{
	LOOKAHEAD(3) unaryExpression() |
	"(" typeName() ")" castExpression()
}

void multiplicativeExpression() : {}
{
	castExpression() ( ( "*" | "/" | "%" ) castExpression() )*
}

void additiveExpression() : {}
{
	multiplicativeExpression() ( ( "+" | "-" ) multiplicativeExpression() )*
}

void shiftExpression() : {}
{
	additiveExpression() ( ( "<<" | ">>" ) additiveExpression() )*
}

void relationalExpression() : {}
{
	shiftExpression() ( ( "<" | ">" | "<=" | ">=" ) shiftExpression() )*
}

void equalityExpression() : {}
{
	relationalExpression() ( ( "==" | "!=" ) relationalExpression() )*
}

void andExpression() : {}
{
	equalityExpression() ( "&" equalityExpression() )*
}

void exclusiveOrExpression() : {}
{
	andExpression() ( "^" andExpression() )*
}

void inclusiveOrExpression() : {}
{
	exclusiveOrExpression() ( "|" exclusiveOrExpression() )*
}

void logicalAndExpression() : {}
{
	inclusiveOrExpression() ( "&&" inclusiveOrExpression() )*
}

void logicalOrExpression() : {}
{
	logicalAndExpression() ( "||" logicalAndExpression() )*
}

void conditionalExpression() : {}
{
	LOOKAHEAD(3) logicalOrExpression() |
	logicalOrExpression() "?" expression()  ":" conditionalExpression()
}

void assignmentExpression() : {}
{
	LOOKAHEAD(3) conditionalExpression() |
	unaryExpression() assignmentOperator() assignmentExpression()
}

void assignmentOperator() : {}
{
	"=" |
	"*=" |
	"/=" |
	"%=" |
	"+=" |
	"-=" |
	"<<=" |
	">>=" |
	"&=" |
	"^=" |
	"|="
}

void expression() : {}
{
	assignmentExpression() ( "," assignmentExpression() )*
}

void constantExpression() : {}
{
	conditionalExpression()
}

/************************************ Identifiers ************************************/

void constant() : {}
{
	<INTEGER_LITERAL> |
	<FLOATING_POINT_LITERAL> |
	<CHARACTER_LITERAL> |
	<STRING_LITERAL>
}